import type { DimensionsI } from "~/server/models/InventoryItem";
import type { CartItemI } from "~/server/models/subdocuments/Cart";
import Setting from "~/server/models/Setting";
import safeAwait from "safe-await";

export const packInBins = async (itemsRef: CartItemI[]) => {
  let [binsError, binsSetting] = await safeAwait(Setting.findOne({
    type: 'shipping',
    subtype: 'config',
    name: 'bins'
  }));

  console.log('arst')


  if(binsError || !binsSetting?.value || !((binsSetting?.value?.length || []) > 0)) {
    console.error(binsError);
    throw createError({
      statusCode: 400,
      statusMessage: 'Bins are not configured correctly or there was a server error.'
    });
  }

  console.log('check');

  const availableBins = [...(binsSetting?.value as DimensionsI[] || [])];
  availableBins.sort((a, b) => {
    const bVol = b.height * b.length * b.width;
    const aVol = a.height * a.length * a.width;
    return aVol - bVol;
  }).reverse();
  const items = [...itemsRef];
  items.sort((a, b) => {
    const aBig = Math.max(a.item.dimensions.length, a.item.dimensions.height, a.item.dimensions.width);
    const bBig = Math.max(b.item.dimensions.length, b.item.dimensions.height, b.item.dimensions.width);
    return aBig - bBig;
  }).reverse();


  // This keeps track of the number of items left to pack
  const itemsQty = items.map(item => item.quantity); 
  const packedBins: PackedBox[] = [];

  console.log(!itemsQty.every((qty) => qty === 0))
  console.log('check2');

  // Pack the bins!
  while(!itemsQty.every((qty) => qty <= 0)) {
    console.log('while')
    // Pack a new box every time the loop executes
    console.log(itemsQty);
    const currentBox = packBin(items, availableBins[0], itemsQty);
    console.log(itemsQty);
    console.log(currentBox);
    packedBins.push(currentBox);
    break;
  }

  console.log(packedBins);
  return packedBins;

  /*

  console.log('blueface');



  // Here I attempt to pack the boxes in smaller boxes to save shipping
  for(const binIndex in packedBins) {
    const bin = packedBins[binIndex];
    const binItems: CartItemI[] = [];
    // Recreate the bin
    for(const key of bin.items.keys()) {
      const cartItem = items.find(item => item.item._id === key);
      if(cartItem) {
        binItems.push({
          item: cartItem.item,
          quantity: bin.items.get(key) || 0,
          fieldAnswers: []
        });
      }
    }

    while(true) {
      const binSize = packedBins[binIndex].dimensions;
      const newBinIndex = availableBins.findIndex(abin => 
        binSize.width === abin.width && 
          binSize.height === abin.height &&
          binSize.length === abin.length
      );

      const tmpItemsQty = binItems.map(binItem => binItem.quantity);
      const newBin = availableBins[newBinIndex + 1];
      const packedSmallerBin = packBin(binItems, newBin, tmpItemsQty);
      if(!tmpItemsQty.every(qty => qty === 0)) {
        break;
      }

      packedBins[binIndex] = packedSmallerBin;
    }
  }

  // Remember this is a greedy algorithm
  // Remember that the most important thing is not to cost nikki more money than we charge the customer.
  */
  return packedBins;
}

/*
 * itemSet and itemTracker should have items that correspond the the same index
 * itemTracker should be an array of positive numbers representing the number of
 * unpacked items in each index of itemSet
 * binToPack is the dimensions of the bin being packed
 */
const packBin = (itemSet: CartItemI[], binToPack: DimensionsI, itemTracker: number[]): PackedBox => {

  const currentBox : PackedBox = {
    dimensions: binToPack,
    items: new Map<number, number>()
  }

  const openSpots : DimensionsI[] = [
    currentBox.dimensions
  ];

  for(const itemIndex in itemSet) {
    const item = itemSet[itemIndex];
    itemTracker[itemIndex]--;
    // While there is a spot large enough to fit the item I'm currently looking at
    // And there are any items that still need to be packed
    /*
    while(openSpots.some(spot => fitsInBin(item.item.dimensions, spot)) && itemTracker[itemIndex] > 0) {
      openSpots.sort((a, b) => {
        return a.length * a.width * a.height - b.length * b.width * b.height;
      }).reverse(); // Sort from largest to smallest

      // Add the item to the box
      const smallestSpotThatFitsIndex = openSpots.findLastIndex(spot => fitsInBin(item.item.dimensions, spot));
      const itemQty : number = currentBox.items.get(item.item._id) || 0;
      currentBox.items.set(item.item._id, itemQty + 1); 
      itemTracker[itemIndex]--;

      if(itemTracker[itemIndex] < 0) throw new Error('There was an error with the bin tracker');

      // Slice the box
      const smallestSpotThatFits = openSpots[smallestSpotThatFitsIndex];
      openSpots.splice(smallestSpotThatFitsIndex, 1);
      openSpots.push(...sliceBox(smallestSpotThatFits, item.item.dimensions));
    }
  */
  }

  return currentBox;
}

export const fitsInBin = (item: DimensionsI, bin : DimensionsI) => {
  const itemDims = [item.length, item.height, item.width];
  const binDims = [bin.length, bin.height, bin.width];

  itemDims.sort();
  binDims.sort();

  return itemDims[0] <= binDims[0] &&
    itemDims[1] <= binDims[1] &&
    itemDims[2] <= binDims[2]
};

const sliceBox = (spotDims: DimensionsI, itemDims: DimensionsI) => {
  const newSpots = [];
  const spotDimsInOrder = [spotDims.width, spotDims.length, spotDims.height].sort();
  const itemDimsInOrder = [itemDims.width, itemDims.length, itemDims.height].sort();

  // TODO: There is an optimization available here regarding selecting the orientation of the box.
  // TODO: Select the first cut based on which resulting box has the most volume after the cut
  // Note that these are both bug-prone and will require some rigorous proving
  if(spotDimsInOrder[2] - itemDimsInOrder[2] > 0) {
    newSpots.push({
      height: spotDimsInOrder[0],
      length: spotDimsInOrder[1],
      width: spotDimsInOrder[2] - itemDimsInOrder[2]
    }); // First cut
  }

  if(spotDimsInOrder[1] - itemDimsInOrder[1] > 0) {
    newSpots.push({
      height: spotDimsInOrder[0],
      length: spotDimsInOrder[1] - itemDimsInOrder[1],
      width: itemDimsInOrder[2]
    });
  }

  if(spotDimsInOrder[0] - itemDimsInOrder[0] > 0) {
    newSpots.push({
      height: spotDimsInOrder[0] - itemDimsInOrder[0],
      length: itemDimsInOrder[1],
      width: itemDimsInOrder[2]
    });
  }

  return newSpots;
}

// The key in the map is an object id for an inventory item, while the value is the quantity of that item.
interface PackedBox {
  dimensions: DimensionsI;
  items: Map<number, number>
}
